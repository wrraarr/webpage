<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Direction Agent Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            overflow-x: hidden;
        }

        .controls-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            flex: 1;
            min-width: 400px;
        }

        .control-panel h3 {
            margin-top: 0;
            color: #4ecdc4;
            border-bottom: 2px solid #4ecdc4;
            padding-bottom: 5px;
        }

        .control-group {
            display: inline-block;
            margin: 10px 20px 10px 0;
            vertical-align: top;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 12px;
        }

        .control-group input {
            padding: 5px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            width: 100px;
        }

        .control-group input[type="range"] {
            width: 120px;
        }

        .control-group button {
            padding: 8px 16px;
            border-radius: 5px;
            border: none;
            background: #4ecdc4;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }

        .size-controls {
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            margin-top: 15px;
            padding-top: 15px;
        }

        .size-controls h4 {
            margin: 0 0 10px 0;
            color: #ff9f43;
        }

        .simulation-area {
            position: relative;
            height: 50vh;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .graph-container {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .graph-container input[type="range"] {
            width: 80px;   /* much smaller */
            height: 4px;   /* thinner track */
        }


        .graph-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .graph-controls h3 {
            margin: 0;
            color: #4ecdc4;
        }

        .graph-area {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            position: relative;
        }

        #performanceGraph {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            display: block;
        }

        .graph-legend {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .start-line-horizontal {
            position: absolute;
            right: 0;
            background: rgba(255, 107, 107, 0.5);
            width: 3px;
            transition: height 0.3s ease;
        }

        .start-line-vertical {
            position: absolute;
            top: 0;
            background: rgba(52, 152, 219, 0.5);
            height: 3px;
            transition: width 0.3s ease;
        }

        .agent-horizontal {
            position: absolute;
            background: radial-gradient(circle, #ff6b6b, #ee5a52);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.6);
            width: 12px;
            height: 12px;
        }

        .agent-vertical {
            position: absolute;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.6);
        }

        .agent-vertical.size-tiny {
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, #3498db, #2980b9);
        }

        .agent-vertical.size-small {
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #5dade2, #3498db);
        }

        .agent-vertical.size-medium {
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, #85c1e9, #5dade2);
        }

        .agent-vertical.size-large {
            width: 12px;
            height: 12px;
            background: radial-gradient(circle, #aed6f1, #85c1e9);
        }

        .stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 11px;
            line-height: 1.4;
        }

        .value-display {
            color: #4ecdc4;
            font-weight: bold;
        }

        .stats-section {
            margin-bottom: 10px;
        }

        .stats-title {
            color: #ff9f43;
            font-weight: bold;
            margin-bottom: 3px;
        }

        #performanceGraph {
            width: 100%;
            height: 200px;
            display: block;
        }

    </style>
</head>
<body>
    <h1>Multi-Direction Agent Simulation</h1>
    
    <div class="simulation-area" id="simulationArea">
        <div class="start-line-horizontal" id="hStartLine"></div>
        <div class="start-line-vertical" id="vStartLine"></div>
        
        <div class="stats" id="stats">
            <div class="stats-section">
                <div class="stats-title">Horizontal Agents</div>
                Active: <span id="hAgentCount">0</span><br>
                Total: <span id="hTotalSpawned">0</span>
            </div>
            <div class="stats-section">
                <div class="stats-title">Vertical Agents</div>
                Active: <span id="vAgentCount">0</span><br>
                Total: <span id="vTotalSpawned">0</span><br>
                <small>
                    Tiny: <span id="tinyCount">0</span> |
                    Small: <span id="smallCount">0</span><br>
                    Medium: <span id="mediumCount">0</span> |
                    Large: <span id="largeCount">0</span>
                </small>
            </div>
        </div>
    </div>

    <div class="graph-container">
        <div class="graph-controls">
            <h3>ðŸ“Š Performance Analytics</h3>
            
            <div class="control-group">
                <label for="collisionRadius">Collision Sensitivity:</label>
                <input type="range" id="collisionRadius" min="5" max="25" value="12">
                <span class="value-display" id="collisionRadiusValue">12px</span>
            </div>

            <div class="control-group">
                <label for="sampleRate">Sample Rate:</label>
                <input type="range" id="sampleRate" min="100" max="2000" step="100" value="500">
                <span class="value-display" id="sampleRateValue">500ms</span>
            </div>
        </div>

        <div class="graph-area">
            <canvas id="performanceGraph"></canvas>
            <div class="graph-legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b;"></div>
                    <span>Collisions/sec</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4ecdc4;"></div>
                    <span>Avg Transit Time (s)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff9f43;"></div>
                    <span>Active Agents Total</span>
                </div>
            </div>
        </div>
    </div>

    

    <div class="controls-container">
        <!-- Horizontal Agents Controls -->
        <div class="control-panel">
            <h3>ðŸ”´ Horizontal Agents (Right â†’ Left)</h3>
            
            <div class="control-group">
                <label for="hStartLineWidth">Start Line Width:</label>
                <input type="range" id="hStartLineWidth" min="50" max="400" value="200">
                <span class="value-display" id="hStartLineWidthValue">200px</span>
            </div>

            <div class="control-group">
                <label for="hSpawnRate">Spawn Rate:</label>
                <input type="range" id="hSpawnRate" min="50" max="1000" value="300">
                <span class="value-display" id="hSpawnRateValue">300ms</span>
            </div>

            <div class="control-group">
                <label for="hMinSpeed">Min Speed:</label>
                <input type="range" id="hMinSpeed" min="0.5" max="5" step="0.1" value="1">
                <span class="value-display" id="hMinSpeedValue">1.0</span>
            </div>

            <div class="control-group">
                <label for="hMaxSpeed">Max Speed:</label>
                <input type="range" id="hMaxSpeed" min="1" max="10" step="0.1" value="3">
                <span class="value-display" id="hMaxSpeedValue">3.0</span>
            </div>

            <div class="control-group">
                <label>&nbsp;</label>
                <button id="hPauseBtn">Pause</button>
            </div>
        </div>

        <!-- Vertical Agents Controls -->
        <div class="control-panel">
            <h3>ðŸ”µ Vertical Agents (Top â†’ Bottom)</h3>
            
            <div class="control-group">
                <label for="vStartLineWidth">Start Line Width:</label>
                <input type="range" id="vStartLineWidth" min="50" max="400" value="250">
                <span class="value-display" id="vStartLineWidthValue">250px</span>
            </div>

            <div class="control-group">
                <label for="vSpawnRate">Spawn Rate:</label>
                <input type="range" id="vSpawnRate" min="50" max="1000" value="400">
                <span class="value-display" id="vSpawnRateValue">400ms</span>
            </div>

            <div class="control-group">
                <label for="vMinSpeed">Min Speed:</label>
                <input type="range" id="vMinSpeed" min="0.5" max="5" step="0.1" value="0.8">
                <span class="value-display" id="vMinSpeedValue">0.8</span>
            </div>

            <div class="control-group">
                <label for="vMaxSpeed">Max Speed:</label>
                <input type="range" id="vMaxSpeed" min="1" max="10" step="0.1" value="2.5">
                <span class="value-display" id="vMaxSpeedValue">2.5</span>
            </div>

            <div class="control-group">
                <label>&nbsp;</label>
                <button id="vPauseBtn">Pause</button>
            </div>

            <div class="size-controls">
                <h4>Size Distribution (%)</h4>
                
                <div class="control-group">
                    <label for="sizeTiny">Tiny (6px):</label>
                    <input type="range" id="sizeTiny" min="0" max="100" value="30">
                    <span class="value-display" id="sizeTinyValue">30%</span>
                </div>

                <div class="control-group">
                    <label for="sizeSmall">Small (8px):</label>
                    <input type="range" id="sizeSmall" min="0" max="100" value="30">
                    <span class="value-display" id="sizeSmallValue">30%</span>
                </div>

                <div class="control-group">
                    <label for="sizeMedium">Medium (10px):</label>
                    <input type="range" id="sizeMedium" min="0" max="100" value="25">
                    <span class="value-display" id="sizeMediumValue">25%</span>
                </div>

                <div class="control-group">
                    <label for="sizeLarge">Large (12px):</label>
                    <input type="range" id="sizeLarge" min="0" max="100" value="15">
                    <span class="value-display" id="sizeLargeValue">15%</span>
                </div>
            </div>
        </div>
    </div>
<script>
class MultiDirectionSimulation {
    constructor() {
        this.horizontalAgents = [];
        this.verticalAgents = [];
        this.hIsRunning = true;
        this.vIsRunning = true;
        this.hSpawnInterval = null;
        this.vSpawnInterval = null;
        this.animationId = null;
        this.hTotalSpawned = 0;
        this.vTotalSpawned = 0;
        this.sizeCounts = { tiny: 0, small: 0, medium: 0, large: 0 };

        // Graph stuff
        this.graphCtx = document.getElementById('performanceGraph').getContext('2d');
        this.graphData = { collisions: [], transitTimes: [], activeAgents: [] };
        this.collisionCount = 0;
        this.completedTransitTimes = [];

        // Sample every N ms
        this.sampleRate = parseInt(document.getElementById('sampleRate').value);
        setInterval(() => this.sampleGraphData(), this.sampleRate);

        this.initializeControls();
        this.updateStartLines();
        this.resizeGraphCanvas();
        this.startSimulation();
    }

    initializeControls() {
        this.initHorizontalControls();
        this.initVerticalControls();
        this.initSizeControls();

        // Sample rate slider
        document.getElementById('sampleRate').addEventListener('input', (e) => {
            this.sampleRate = parseInt(e.target.value);
            document.getElementById('sampleRateValue').textContent = this.sampleRate + "ms";
        });
    }

    initHorizontalControls() {
        const hStartLineWidth = document.getElementById('hStartLineWidth');
        const hStartLineWidthValue = document.getElementById('hStartLineWidthValue');
        hStartLineWidth.addEventListener('input', (e) => {
            hStartLineWidthValue.textContent = e.target.value + 'px';
            this.updateStartLines();
        });

        const hSpawnRate = document.getElementById('hSpawnRate');
        const hSpawnRateValue = document.getElementById('hSpawnRateValue');
        hSpawnRate.addEventListener('input', (e) => {
            hSpawnRateValue.textContent = e.target.value + 'ms';
            this.updateHorizontalSpawnRate();
        });

        const hMinSpeed = document.getElementById('hMinSpeed');
        const hMinSpeedValue = document.getElementById('hMinSpeedValue');
        hMinSpeed.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            hMinSpeedValue.textContent = value.toFixed(1);
            this.validateSpeedRange('h', value, 'min');
        });

        const hMaxSpeed = document.getElementById('hMaxSpeed');
        const hMaxSpeedValue = document.getElementById('hMaxSpeedValue');
        hMaxSpeed.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            hMaxSpeedValue.textContent = value.toFixed(1);
            this.validateSpeedRange('h', value, 'max');
        });

        const hPauseBtn = document.getElementById('hPauseBtn');
        hPauseBtn.addEventListener('click', () => {
            this.toggleHorizontalPause();
        });
    }

    initVerticalControls() {
        const vStartLineWidth = document.getElementById('vStartLineWidth');
        const vStartLineWidthValue = document.getElementById('vStartLineWidthValue');
        vStartLineWidth.addEventListener('input', (e) => {
            vStartLineWidthValue.textContent = e.target.value + 'px';
            this.updateStartLines();
        });

        const vSpawnRate = document.getElementById('vSpawnRate');
        const vSpawnRateValue = document.getElementById('vSpawnRateValue');
        vSpawnRate.addEventListener('input', (e) => {
            vSpawnRateValue.textContent = e.target.value + 'ms';
            this.updateVerticalSpawnRate();
        });

        const vMinSpeed = document.getElementById('vMinSpeed');
        const vMinSpeedValue = document.getElementById('vMinSpeedValue');
        vMinSpeed.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            vMinSpeedValue.textContent = value.toFixed(1);
            this.validateSpeedRange('v', value, 'min');
        });

        const vMaxSpeed = document.getElementById('vMaxSpeed');
        const vMaxSpeedValue = document.getElementById('vMaxSpeedValue');
        vMaxSpeed.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            vMaxSpeedValue.textContent = value.toFixed(1);
            this.validateSpeedRange('v', value, 'max');
        });

        const vPauseBtn = document.getElementById('vPauseBtn');
        vPauseBtn.addEventListener('click', () => {
            this.toggleVerticalPause();
        });
    }

    initSizeControls() {
        const sizeTypes = ['sizeTiny', 'sizeSmall', 'sizeMedium', 'sizeLarge'];
        sizeTypes.forEach(sizeType => {
            const slider = document.getElementById(sizeType);
            const value = document.getElementById(sizeType + 'Value');
            slider.addEventListener('input', (e) => {
                value.textContent = e.target.value + '%';
                this.normalizeSizeDistribution(sizeType);
            });
        });
    }

    normalizeSizeDistribution(changedType) {
        const sizeTypes = ['sizeTiny', 'sizeSmall', 'sizeMedium', 'sizeLarge'];
        const sliders = sizeTypes.map(id => document.getElementById(id));
        const total = sliders.reduce((sum, slider) => sum + parseInt(slider.value), 0);
        if (total > 100) {
            const excess = total - 100;
            const others = sizeTypes.filter(type => type !== changedType);
            const otherTotal = others.reduce((sum, type) => sum + parseInt(document.getElementById(type).value), 0);
            if (otherTotal > 0) {
                others.forEach(type => {
                    const slider = document.getElementById(type);
                    const proportion = parseInt(slider.value) / otherTotal;
                    const reduction = Math.floor(excess * proportion);
                    const newValue = Math.max(0, parseInt(slider.value) - reduction);
                    slider.value = newValue;
                    document.getElementById(type + 'Value').textContent = newValue + '%';
                });
            }
        }
    }

    validateSpeedRange(prefix, value, type) {
        const minSlider = document.getElementById(prefix + 'MinSpeed');
        const maxSlider = document.getElementById(prefix + 'MaxSpeed');
        const minValue = document.getElementById(prefix + 'MinSpeedValue');
        const maxValue = document.getElementById(prefix + 'MaxSpeedValue');
        if (type === 'min' && value >= parseFloat(maxSlider.value)) {
            maxSlider.value = (value + 0.1).toFixed(1);
            maxValue.textContent = maxSlider.value;
        } else if (type === 'max' && value <= parseFloat(minSlider.value)) {
            minSlider.value = (value - 0.1).toFixed(1);
            minValue.textContent = minSlider.value;
        }
    }

    updateStartLines() {
        const simulationArea = document.getElementById('simulationArea');
        const maxHeight = simulationArea.clientHeight;
        const maxWidth = simulationArea.clientWidth;

        const hStartLine = document.getElementById('hStartLine');
        const hWidth = document.getElementById('hStartLineWidth').value;
        hStartLine.style.height = hWidth + 'px';
        hStartLine.style.top = Math.max(0, (maxHeight - parseInt(hWidth)) / 2) + 'px';

        const vStartLine = document.getElementById('vStartLine');
        const vWidth = document.getElementById('vStartLineWidth').value;
        vStartLine.style.width = vWidth + 'px';
        vStartLine.style.left = Math.max(0, (maxWidth - parseInt(vWidth)) / 2) + 'px';
    }

    updateHorizontalSpawnRate() {
        if (this.hSpawnInterval) clearInterval(this.hSpawnInterval);
        if (this.hIsRunning) this.startHorizontalSpawning();
    }

    updateVerticalSpawnRate() {
        if (this.vSpawnInterval) clearInterval(this.vSpawnInterval);
        if (this.vIsRunning) this.startVerticalSpawning();
    }

    startSimulation() {
        this.startHorizontalSpawning();
        this.startVerticalSpawning();
        this.animate();
    }

    startHorizontalSpawning() {
        const spawnRate = parseInt(document.getElementById('hSpawnRate').value);
        this.hSpawnInterval = setInterval(() => {
            if (this.hIsRunning) this.spawnHorizontalAgent();
        }, spawnRate);
    }

    startVerticalSpawning() {
        const spawnRate = parseInt(document.getElementById('vSpawnRate').value);
        this.vSpawnInterval = setInterval(() => {
            if (this.vIsRunning) this.spawnVerticalAgent();
        }, spawnRate);
    }

    getRandomSize() {
        const tiny = parseInt(document.getElementById('sizeTiny').value);
        const small = parseInt(document.getElementById('sizeSmall').value);
        const medium = parseInt(document.getElementById('sizeMedium').value);
        const large = parseInt(document.getElementById('sizeLarge').value);
        const total = tiny + small + medium + large;
        if (total === 0) return 'tiny';
        const random = Math.random() * total;
        let cumulative = 0;
        cumulative += tiny; if (random < cumulative) return 'tiny';
        cumulative += small; if (random < cumulative) return 'small';
        cumulative += medium; if (random < cumulative) return 'medium';
        return 'large';
    }

    spawnHorizontalAgent() {
        const simulationArea = document.getElementById('simulationArea');
        const startLineWidth = parseInt(document.getElementById('hStartLineWidth').value);
        const minSpeed = parseFloat(document.getElementById('hMinSpeed').value);
        const maxSpeed = parseFloat(document.getElementById('hMaxSpeed').value);

        const agent = document.createElement('div');
        agent.className = 'agent-horizontal';

        const startLineTop = Math.max(0, (simulationArea.clientHeight - startLineWidth) / 2);
        const randomY = startLineTop + Math.random() * startLineWidth;
        const speed = minSpeed + Math.random() * (maxSpeed - minSpeed);

        agent.style.right = '0px';
        agent.style.top = randomY + 'px';
        agent.agentData = {
            speed: speed,
            x: simulationArea.clientWidth,
            spawnTime: performance.now()
        };

        simulationArea.appendChild(agent);
        this.horizontalAgents.push(agent);
        this.hTotalSpawned++;
    }

    spawnVerticalAgent() {
        const simulationArea = document.getElementById('simulationArea');
        const startLineWidth = parseInt(document.getElementById('vStartLineWidth').value);
        const minSpeed = parseFloat(document.getElementById('vMinSpeed').value);
        const maxSpeed = parseFloat(document.getElementById('vMaxSpeed').value);

        const agent = document.createElement('div');
        const size = this.getRandomSize();
        agent.className = `agent-vertical size-${size}`;

        const startLineLeft = Math.max(0, (simulationArea.clientWidth - startLineWidth) / 2);
        const randomX = startLineLeft + Math.random() * startLineWidth;
        const speed = minSpeed + Math.random() * (maxSpeed - minSpeed);

        agent.style.left = randomX + 'px';
        agent.style.top = '0px';
        agent.agentData = {
            speed: speed,
            y: 0,
            size: size,
            spawnTime: performance.now()
        };

        simulationArea.appendChild(agent);
        this.verticalAgents.push(agent);
        this.vTotalSpawned++;
        this.sizeCounts[size]++;
    }

    animate() {
        if (this.hIsRunning) this.moveHorizontalAgents();
        if (this.vIsRunning) this.moveVerticalAgents();
        this.checkCollisions();
        this.updateStats();
        this.updateGraph();
        this.animationId = requestAnimationFrame(() => this.animate());
    }

    moveHorizontalAgents() {
        for (let i = this.horizontalAgents.length - 1; i >= 0; i--) {
            const agent = this.horizontalAgents[i];
            const agentData = agent.agentData;
            agentData.x -= agentData.speed;
            agent.style.left = agentData.x + 'px';
            agent.style.right = 'auto';
            if (agentData.x < -20) {
                this.completedTransitTimes.push(performance.now() - agentData.spawnTime);
                agent.remove();
                this.horizontalAgents.splice(i, 1);
            }
        }
    }

    moveVerticalAgents() {
        const simulationArea = document.getElementById('simulationArea');
        for (let i = this.verticalAgents.length - 1; i >= 0; i--) {
            const agent = this.verticalAgents[i];
            const agentData = agent.agentData;
            agentData.y += agentData.speed;
            agent.style.top = agentData.y + 'px';
            if (agentData.y > simulationArea.clientHeight + 20) {
                this.completedTransitTimes.push(performance.now() - agentData.spawnTime);
                agent.remove();
                this.verticalAgents.splice(i, 1);
                this.sizeCounts[agentData.size]--;
            }
        }
    }

    checkCollisions() {
        const radius = parseInt(document.getElementById('collisionRadius').value);
        for (let h of this.horizontalAgents) {
            const hx = h.agentData.x;
            const hy = parseFloat(h.style.top);
            for (let v of this.verticalAgents) {
                const vx = parseFloat(v.style.left);
                const vy = v.agentData.y;
                const dx = hx - vx;
                const dy = hy - vy;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < radius) {
                    this.collisionCount++;
                }
            }
        }
    }

    sampleGraphData() {
        const avgTransit = this.completedTransitTimes.length > 0
            ? (this.completedTransitTimes.reduce((a,b) => a+b, 0) / this.completedTransitTimes.length) / 1000
            : 0;
        const activeCount = this.horizontalAgents.length + this.verticalAgents.length;
        this.graphData.collisions.push(this.collisionCount);
        this.graphData.transitTimes.push(avgTransit);
        this.graphData.activeAgents.push(activeCount);
        if (this.graphData.collisions.length > 80) {
            this.graphData.collisions.shift();
            this.graphData.transitTimes.shift();
            this.graphData.activeAgents.shift();
        }
        this.collisionCount = 0;
        this.completedTransitTimes = [];
    }

    updateStats() {
        document.getElementById('hAgentCount').textContent = this.horizontalAgents.length;
        document.getElementById('hTotalSpawned').textContent = this.hTotalSpawned;
        document.getElementById('vAgentCount').textContent = this.verticalAgents.length;
        document.getElementById('vTotalSpawned').textContent = this.vTotalSpawned;
        document.getElementById('tinyCount').textContent = this.sizeCounts.tiny;
        document.getElementById('smallCount').textContent = this.sizeCounts.small;
        document.getElementById('mediumCount').textContent = this.sizeCounts.medium;
        document.getElementById('largeCount').textContent = this.sizeCounts.large;
    }

    updateGraph() {
        const ctx = this.graphCtx;
        const w = ctx.canvas.width;
        const h = ctx.canvas.height;
        ctx.clearRect(0, 0, w, h);

        const maxCollisions = Math.max(...this.graphData.collisions, 1);
        const maxTransit = Math.max(...this.graphData.transitTimes, 1);
        const maxAgents = Math.max(...this.graphData.activeAgents, 1);

        const drawLine = (data, color, maxValue) => {
            ctx.strokeStyle = color;
            ctx.beginPath();
            data.forEach((val, i) => {
                const x = (i / data.length) * w;
                const y = h - (val / maxValue) * h;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
        };

        drawLine(this.graphData.collisions, "#ff6b6b", maxCollisions);
        drawLine(this.graphData.transitTimes, "#4ecdc4", maxTransit);
        drawLine(this.graphData.activeAgents, "#ff9f43", maxAgents);
    }

    resizeGraphCanvas() {
        const simArea = document.getElementById('simulationArea');
        const canvas = document.getElementById('performanceGraph');
        const ctx = this.graphCtx;

        canvas.width = simArea.clientWidth;  // drawing resolution
        canvas.height = 200;                 // fixed height

        this.graphCtx = ctx; // keep reference
    }


    toggleHorizontalPause() {
        const pauseBtn = document.getElementById('hPauseBtn');
        if (this.hIsRunning) {
            this.hIsRunning = false;
            if (this.hSpawnInterval) clearInterval(this.hSpawnInterval);
            pauseBtn.textContent = 'Resume';
            pauseBtn.style.background = '#e74c3c';
        } else {
            this.hIsRunning = true;
            this.startHorizontalSpawning();
            pauseBtn.textContent = 'Pause';
            pauseBtn.style.background = '#4ecdc4';
        }
    }

    toggleVerticalPause() {
        const pauseBtn = document.getElementById('vPauseBtn');
        if (this.vIsRunning) {
            this.vIsRunning = false;
            if (this.vSpawnInterval) clearInterval(this.vSpawnInterval);
            pauseBtn.textContent = 'Resume';
            pauseBtn.style.background = '#e74c3c';
        } else {
            this.vIsRunning = true;
            this.startVerticalSpawning();
            pauseBtn.textContent = 'Pause';
            pauseBtn.style.background = '#4ecdc4';
        }
    }
}

window.addEventListener('load', () => {
    new MultiDirectionSimulation();
});
window.addEventListener('resize', () => sim.resizeGraphCanvas());
</script>

</body>
</html>